\hypertarget{classtask__share_1_1Queue}{}\section{task\+\_\+share.\+Queue Class Reference}
\label{classtask__share_1_1Queue}\index{task\+\_\+share.\+Queue@{task\+\_\+share.\+Queue}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{classtask__share_1_1Queue_a91ce05bf47c2634013fdb2689c2b207f}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, type\+\_\+code, size, thread\+\_\+protect=True, overwrite=False, name=None)
\item 
def \mbox{\hyperlink{classtask__share_1_1Queue_ae785bdf9d397d61729c22656471a81df}{put}} (self, item, in\+\_\+\+I\+SR=False)
\item 
def \mbox{\hyperlink{classtask__share_1_1Queue_af2aef1dd3eed21c4b6c2e601cb8497d4}{get}} (self, in\+\_\+\+I\+SR=False)
\item 
def \mbox{\hyperlink{classtask__share_1_1Queue_a7cb2d23978b90a232cf9cea4cc0ccb6b}{any}} (self)
\item 
def \mbox{\hyperlink{classtask__share_1_1Queue_af9ada059fc09a44adc9084901e2f7266}{empty}} (self)
\item 
def \mbox{\hyperlink{classtask__share_1_1Queue_a0482d70ce6405fd8d85628b5cf95d471}{full}} (self)
\item 
def \mbox{\hyperlink{classtask__share_1_1Queue_a713321bacac5d93ecf89c4be1c15fe30}{num\+\_\+in}} (self)
\item 
def \mbox{\hyperlink{classtask__share_1_1Queue_a94d0801557844c8f7dcb772ca768a1a4}{\+\_\+\+\_\+repr\+\_\+\+\_\+}} (self)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classtask__share_1_1Queue_a6f9d87b116eb16dba0867d3746af9f5f}{ser\+\_\+num}} = 0
\begin{DoxyCompactList}\small\item\em A counter used to give serial numbers to queues for diagnostic use. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}This class implements a queue which is used to transfer data from one
task to another. If parameter 'thread_protect' is @c True, the transfer 
will be protected from corruption in the case that one thread might 
interrupt another due to threading or due to one thread being run as an 
interrupt service routine. \end{DoxyVerb}
 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classtask__share_1_1Queue_a91ce05bf47c2634013fdb2689c2b207f}\label{classtask__share_1_1Queue_a91ce05bf47c2634013fdb2689c2b207f}} 
\index{task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}!\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}!task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+init\+\_\+\+\_\+()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{type\+\_\+code,  }\item[{}]{size,  }\item[{}]{thread\+\_\+protect = {\ttfamily True},  }\item[{}]{overwrite = {\ttfamily False},  }\item[{}]{name = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Initialize a queue by allocating memory for the contents and 
setting up the components in an empty configuration. The data type 
code is given as for the Python 'array' type, which can be any of
* b (signed char), B (unsigned char)
* h (signed short), H (unsigned short)
* i (signed int), I (unsigned int)
* l (signed long), L (unsigned long)
* q (signed long long), Q (unsigned long long)
* f (float), or d (double-precision float)
@param type_code The type of data items which the queue can hold
@param size The maximum number of items which the queue can hold
@param thread_protect @c True if mutual exclusion protection is used
@param overwrite If @c True, oldest data will be overwritten with new
    data if the queue becomes full 
@param name A short name for the queue, default @c QueueN where @c N
    is a serial number for the queue \end{DoxyVerb}
 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classtask__share_1_1Queue_a94d0801557844c8f7dcb772ca768a1a4}\label{classtask__share_1_1Queue_a94d0801557844c8f7dcb772ca768a1a4}} 
\index{task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}!\+\_\+\+\_\+repr\+\_\+\+\_\+@{\+\_\+\+\_\+repr\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+repr\+\_\+\+\_\+@{\+\_\+\+\_\+repr\+\_\+\+\_\+}!task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+repr\+\_\+\+\_\+()}{\_\_repr\_\_()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+\_\+\+\_\+repr\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method puts diagnostic information about the queue into a 
string. \end{DoxyVerb}
 \mbox{\Hypertarget{classtask__share_1_1Queue_a7cb2d23978b90a232cf9cea4cc0ccb6b}\label{classtask__share_1_1Queue_a7cb2d23978b90a232cf9cea4cc0ccb6b}} 
\index{task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}!any@{any}}
\index{any@{any}!task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}}
\subsubsection{\texorpdfstring{any()}{any()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+any (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns @c True if there are any items in the queue and @c False
if the queue is empty.
@return @c True if items are in the queue, @c False if not \end{DoxyVerb}
 \mbox{\Hypertarget{classtask__share_1_1Queue_af9ada059fc09a44adc9084901e2f7266}\label{classtask__share_1_1Queue_af9ada059fc09a44adc9084901e2f7266}} 
\index{task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}!empty@{empty}}
\index{empty@{empty}!task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}}
\subsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+empty (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns @c True if there are no items in the queue and @c False if 
there are any items therein.
@return @c True if queue is empty, @c False if it's not empty \end{DoxyVerb}
 \mbox{\Hypertarget{classtask__share_1_1Queue_a0482d70ce6405fd8d85628b5cf95d471}\label{classtask__share_1_1Queue_a0482d70ce6405fd8d85628b5cf95d471}} 
\index{task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}!full@{full}}
\index{full@{full}!task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}}
\subsubsection{\texorpdfstring{full()}{full()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+full (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method returns @c True if the queue is already full and there
is no room for more data without overwriting existing data. 
@return @c True if the queue is full \end{DoxyVerb}
 \mbox{\Hypertarget{classtask__share_1_1Queue_af2aef1dd3eed21c4b6c2e601cb8497d4}\label{classtask__share_1_1Queue_af2aef1dd3eed21c4b6c2e601cb8497d4}} 
\index{task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}!get@{get}}
\index{get@{get}!task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}}
\subsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+get (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{in\+\_\+\+I\+SR = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Read an item from the queue. If there isn't anything in there,
wait (blocking the calling process) until something becomes
available. If non-blocking reads are needed, one should call @c any()
to check for items before attempting to read any items.
@param in_ISR Set this to @c True if calling from within an ISR \end{DoxyVerb}
 \mbox{\Hypertarget{classtask__share_1_1Queue_a713321bacac5d93ecf89c4be1c15fe30}\label{classtask__share_1_1Queue_a713321bacac5d93ecf89c4be1c15fe30}} 
\index{task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}!num\+\_\+in@{num\+\_\+in}}
\index{num\+\_\+in@{num\+\_\+in}!task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}}
\subsubsection{\texorpdfstring{num\+\_\+in()}{num\_in()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+num\+\_\+in (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method returns the number of items which are currently in the 
queue.
@return The number of items in the queue \end{DoxyVerb}
 \mbox{\Hypertarget{classtask__share_1_1Queue_ae785bdf9d397d61729c22656471a81df}\label{classtask__share_1_1Queue_ae785bdf9d397d61729c22656471a81df}} 
\index{task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}!put@{put}}
\index{put@{put}!task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}}
\subsubsection{\texorpdfstring{put()}{put()}}
{\footnotesize\ttfamily def task\+\_\+share.\+Queue.\+put (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{item,  }\item[{}]{in\+\_\+\+I\+SR = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Put an item into the queue. If there isn't room for the item, wait 
(blocking the calling process) until room becomes available,
unless the @c overwrite constructor parameter was set to @c True to 
allow old data to be clobbered. If non-blocking behavior without
overwriting is needed, one should call @c full() to ensure that the 
queue is not full before putting data into it.
@param item The item to be placed into the queue
@param in_ISR Set this to @c True if calling from within an ISR \end{DoxyVerb}
 

\subsection{Member Data Documentation}
\mbox{\Hypertarget{classtask__share_1_1Queue_a6f9d87b116eb16dba0867d3746af9f5f}\label{classtask__share_1_1Queue_a6f9d87b116eb16dba0867d3746af9f5f}} 
\index{task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}!ser\+\_\+num@{ser\+\_\+num}}
\index{ser\+\_\+num@{ser\+\_\+num}!task\+\_\+share\+::\+Queue@{task\+\_\+share\+::\+Queue}}
\subsubsection{\texorpdfstring{ser\+\_\+num}{ser\_num}}
{\footnotesize\ttfamily int task\+\_\+share.\+Queue.\+ser\+\_\+num = 0\hspace{0.3cm}{\ttfamily [static]}}



A counter used to give serial numbers to queues for diagnostic use. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{task__share_8py}{task\+\_\+share.\+py}}\end{DoxyCompactItemize}
